# Project Preparation Guidelines

## Overview

This document helps guide you through the preparation phase of a project, which is all about the thinking, researching, brainstorming, evaluation, and/or decision making required in order to create the final set of information that will go into the "Preparation" section of the project document.

## Context

If you're reading this, there should already be a project document for the coding project you're working on. That project document serves as a store of both medium- and long-term memory for all the information that will be useful while coding the project. More specifically, when you eventually get to the coding phase of this project, you will frequently reference information recorded in the project document about the design, architecture, organization, and/or approach for the code. This is much more efficient than having to re-derive this info from scratch.

Preparation is arguably the most important step of any project, besides writing the actual code. And it's important to get it right, however, It's tricky, because different coding projects benefit from entirely different preparation processes. If you're here, you should already have a good idea of what _kind_ of project you're working on, as well as the scope, nature, goals, non-goals, and constraints of the project. This should help you tremendously with preparation.

## Preparation Process

Every project requires its own unique method of preparation. Therefore, this document will not guide you through a very specific step-by-step set of instructions. Instead, your task is to derive your own specific set of instructions, i.e. your own workflow for preparing. To help you build this workflow, this document will provide you with a set of building blocks that you can choose from and stitch together in an intelligent order to create your preparation workflow, and as well as some guidelines for how to do this well.

### List of Preparation Building Blocks

**Information Gathering.** This is the process of researching to compile information that will be useful for later steps. Although the process of information gathering might be long and tedious and consume lots of tokens, the output should be concise, specific, relevant, and useful for accomplishing future steps. The primary benefit here is that you can do this tedious work once, and then quickly reference the information gleaned in the future without having to repeat the process. Thus, it's important to put the information gathering steps first, before other steps that benefit from having the information. It's also important to scope each information gathering step. For example, is the purpose to gather information about existing patterns or data structures or functions in the codebase so that they can be used and our code can be DRY? Or is the purpose to research what work has already been done on a task so we can understand the context and do appropriate cleanup/refactoring/workarounds? Or perhaps the purpose is to gather up-to-date information on useful APIs? Etc. The scope and purpose of information gathering should always be explicitly stated upfront. It's common to have multiple information gathering steps per workflow. The output of each information gathering steps should generally be a bullet list outline of relevant information. It should not contain code blocks, but can contain descriptions of code, functions, etc.

**Brainstorming.** This is the process of generating a variety of ideas or approaches, e.g. for architecture or design decisions. It's particularly useful when it's clear that there are numerous ways to design, architect, or build something, but it's not obvious what the best choice is from the outside, as each requires careful evaluation. To do brainstorming well, it's important to begin by constructing a large and wide-ranging list up front. Just how large is up to you. For simple projects or simple parts of a complex project, it's often best to skip brainstorming and go with an obvious solution. For intermediate or semi-important steps, it's often useful to brainstorming 3-5 options. For very complex or open-ended or super important decisions, it's often useful to brainstorming lots of different options, 10-20 or more. Brainstorming is subject to "garbage in, garbage out", so it's important for brainstormed options to be as good as possible, and thus brainstorming is often preceded by information gathering. Brainstorming is almost always followed by review (to ensure the brainstorming was thorough), and then the creation and application of a rubric to evaluate options, in order to pick the best one. It's important to then record the final decision and some of the justification behind it.

**Flow and Scenario Mapping.** Almost all projects involve writing or architecting code. And all code has a beginning point where it's first initiated, from which the code follows an execution path—possibly involving branches—until it ends. In a user-facing application, it's very common for code execution paths to be initiated by users, either directly or indirectly, who are attempting to accomplish a goal, and to do so within a specific context. Examining code flows and/or use cases is a sometimes-useful process in which you essentially make an exhaustive (within reason) bullet list of all the relevant possibilities. This output can be useful for later steps. This is technically a special case of brainstorming, but is also similar to information gathering in its purpose. Its output is useful for later reference, in that it can surface easily-missed details that might be crucial for the success of the project, e.g. edge cases, point of confusion, special exceptions and needs, etc. It's often useful to augment the items in the list with relevant sub-bullets calling attention to these things.

**Evaluating.** This is the process of evaluating the output of a previous step. Unlike a review, which is generally about making corrections or changes, evaluation is about generating scores/ratings. It's often used after brainstorming, to evaluate a number of options. Evaluation always requires the creation of a rubric, which needs to be thorough and thoughtful, and take into account relevant context and goals and constraints for what's being evaluated. This rubric can then be objectively applied to what's being evaluated, e.g. a plan that was devised, or a set of options. The output of an evaluation step should always be the final score on the rubric for each thing evaluated (whether one thing or numerous options), as well relevant explanation and details that may be useful for future reference, yet not obvious to any who do not see the evaluation process itself. Evaluation requires careful thought.

**Decision Making.** This is the process of making a final decision based on the output of previous steps. It's often used after evaluating a number of options, or even just one option. Decisions can be about anything that's undecided. The output of a decision step should always be a clear and concise statement of the decision, as well as some explanation and details that may be useful for future reference (e.g. tradeoffs, caveats, etc.), yet not obvious to any who do not see the decision process itself.

**Reviewing and Revising.** This is the process of re-reading, re-evaluating, and possibly revising what you did in the previous step of your workflow. It's essentially a second pass. Even the most skilled and experienced programmers make extremely frequent use of this step after practically every step of their workflow, as making a second pass to review what was done is a borderline necessity for catching simple mistakes, oversights, bugs, gaps, or inconsistencies. Thus, it's usually the most-used building block in every workflow. For particularly hairy tasks, sometimes multiple consecutive reviews—reviews of reviews—are necessary. Also, it can be useful during a review to create a checklist of things to look for, and then check them off as you go, as this prevents oversights during the review process. The output of a review should either be a revision to the output of the previous step (which should be recorded), or a simple one-line confirmation that the previous step was done well.

**Synthesizing.** This is the process of combining the output of multiple previous steps into a single coherent output. It's often used after a decision has been made, or after a number of options have been evaluated, to create a final plan. However, sometimes it's used before a decision needs to be made in order to ensure that all the relevant information for that decision is gathered together in one place and can be accurately evaluated. The output of a synthesis step should always be a clear and concise outline.

**Design Specification.** This is the process of walking through a design or architecture in fairly exhaustive detail, with the goal of making it clear and unambiguous to anyone who reads it and must implement it later. This can be done in narrative or outline form. It usually includes lots of important clarifying details, edge cases, decisions, and other things that help resolve ambiguities and to make the design or architecture more clear. It requires great care and an awareness of the "curse of knowledge" to ensure that the reader of the design will understand it, even if they see little-to-nothing else. To that end, it frequently includes explanations of "why" interspersed throughout. It also tries to maximize its understandability, so it tends to recursively explain its concepts and sections from broad to specific, in order to give readers the high-level overview they need to understand the specific details that come later.

**Organize Findings.** This is the process of organizing the output of a previous step, or of the workflow so far, into a coherent and useful format that can be written to the project document inside of its "Preparation" section. Alternatively, this building block can be used to read the project document so far and potentially edit, revise, and reorganize it based on new work that's been done. This building block should be used frequently to ensure that the project document gets updated. It's sort of a "backup" building block, because if the other building blocks are being used correctly, the project document should be getting frequently updated; however this sometimes fails to occur, so inserting this building block into the workflow is a good failsafe. In addition to making updates to the project document, this building block should report to the user what's going on. Some important notes here are that the preparation section of the project document needs to be very well organized, and strike the right balance between being too detailed and too vague. In general, it should never be more than a couple hundred lines long,

**Workflow Adaptation.** This is the process of looking at all the work that's been done so far, as well as what's left to come in the workflow, and deciding to make workflow changes by adding/removing/rearranging building blocks. This is particularly useful to insert in the middle of workflows that are unusually long and complex and thus uncertain. It's incredibly important, as it's a form of high-level review. Thus it should be done throughly, and the project's goals, scope, and constraints should be taken into account, as well as the output of the preparation phase so far. The output of the step should be either a revised workflow or a simple one-line confirmation that the workflow is good as-is.

**Other building blocks.** There are many other potential building blocks of a good workflow. This list is by no means exhaustive. If, when thinking about your workflow, you find it lacking, or there are gaps and things you would wish to include that cannot be created by the building blocks above, feel free to specify and use your own building blocks.

### Compiling Building Blocks into a Workflow

The above building blocks do not stand alone. They must be compiled into a useful workflow. Here are some guidelines for doing so:

- Above all else, consider the scope of the project. Simple, straightforward projects do not require long workflows. In the simplest case, the only prep required may be to immediately produce a design specification, and then review it!
- Always consider the use of your Task tool.
  - You should almost always use your Task tool when executing a building block, especially if you believe that substantial work and effort needs to go into that particular building block.
  - On occasion, for smaller building blocks, you might want to combine multiple of them into a single vacation of your task tool.
  - Regardless, your workflow should clearly specify how to use the Task tool to execute the building blocks.
- As explained above, the "reviewing and revising" building block should be used **extremely frequently**.
  - Not using it after another building block is akin to refusing to check your work, which is something there is rarely an excuse for.
  - You should **almost always** use this building block after every other building block.
- All building blocks have some output that's important to specify when invoking them. Especially when using the Task tool, if the Task tool does not report its conclusions output back to you and/or update the project document, then that work will be lost and useless to the rest of the workflow. So make sure the Task tool does this by giving it specific instructions to this effect.
- Use a mermaid diagram to visualize the workflow. This is a great way to see how the building blocks fit together and how the workflow will progress.

### Running Through the Workflow

The preparation phase begins with constructing a workflow, then continues on to executing (and possibly revising) the building blocks inside that workflow, all the while outputting messages to the user and text into the "Preparation" section of the project document.

The ultimate output of the preparation phase should be subsections inside the "Preparation" section of the project document. But it's important for these writes to be done intermittently throughout the workflow, too.

Remember that the actual behind-the-scenes work that goes on with each building block—the thinking, the research, etc.—will ultimately be invisible. The only actual output that will be preserved and readable by the eventual implement of the project is whatever output of the building blocks and the workflow in general get written to the project document!
